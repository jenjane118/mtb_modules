---
title: "PCA and WCGNA"
output: html_notebook
---

This notebook continues on from 'Mtb_modules_notebook.Rmd", using the counts matrix generated from applying Baerhunter's predicted ncRNAs to multiple Mtb RNAseq datasets. It involves count normalisation, transformation, batch correction, PCA and WGCNA analysis.



```{r message=FALSE}
setwd("~/git/mtb_modules")

        #installation of R packages 
        if (!requireNamespace("BiocManager", quietly = TRUE))
          install.packages("BiocManager")
        #BiocManager::install("Rsubread")
        library(Rsubread)
        #BiocManager::install("DESeq2")
        library(DESeq2)
        #BiocManager::install("sva")
        library(sva)
        #BiocManager::install("limma")
        library(limma)
        #BiocManager::install("WGCNA")
        library(WGCNA)
        #install.packages("devtools")
        #devtools::install_github("hadley/devtools",force=TRUE)
        #library(devtools)
        #devtools::install_github("irilenia/baerhunter",force=TRUE)
        library(baerhunter)
        #devtools::install_github("zhangyuqing/sva-devel")
        #install.packages("ggplot2")
        library(ggplot2)
        #install.packages("dendextend")
        library(dendextend)
        #install.packages("viridis")
        library(viridis)
        library(colorspace)
        library(RColorBrewer)
        library(Rsamtools)
        library(vsn)
```

1) Create counts matrix and DESeq object

Create deseq dataset from counts matrix (can use variety of objects including ranged summarised experiments, etc.). Must include formula for design of experiment.
"By default, the functions in this package will use the last variable in the formula for building results tables and plotting. ~ 1 can be used for no design, although users need to remember to switch to another design for differential testing."

so I don't really have to indicate a 'control' for this experiment since I'm not really going to be looking at differential expression. 


```{r deseq_construct}
# read in counts matrix and create deseq dataset

countdata<-read.csv("count_matrix_complete.csv", header=T, row.names=1)
head(countdata)
#inspection of matrix 
class(countdata)
nrow(countdata)
length(countdata)

# read in sample/dataset
datasets<-read.table("dataset_samples.txt", sep = " ", header=F)
colnames(datasets)<-c("sample", "study")

# read in conditions/sample
conditions<-read.csv("mtb_conditions.txt")
conditions$study<-datasets$study
#View(conditions)

# create DeSeq dataset

#check order is same for count data and conditions data
all(conditions$sample_names == colnames(countdata))
#construct deseq dataset
dds_raw<-DESeqDataSetFromMatrix(countData = countdata,
                              colData = conditions,
                              design = ~1)
nrow(dds_raw)
#6486
# pre-filter reads to exclude rows with very low expression--makes more efficient
keep <- rowSums(counts(dds_raw)) >= 10
dds_filter <- dds_raw[keep,]
nrow(dds_filter)
#6483
# this filters only 3 rows, so not really much point
dds_raw<-dds_filter
```

2) Normalisation  
Sequencing depth normalisation probably quite important here since depth varies quite a bit between experiments.


```{r normalisation}
#sequencing depth normalisation

#calculate size factor
dds_raw<-estimateSizeFactors(dds_raw)
sizeFactors(dds_raw)

#retrieve normalised read counts
counts_normalized<-counts(dds_raw, normalized=TRUE)
class(counts_normalized)
#sum of depth after normalization
colSums(counts(dds_raw, normalized=F))

#boxplot(counts_normalized, notch = TRUE , las=2, cex.axis = 0.7,ylim = c(0,4500),
#        main = "untransformed  read  counts", ylab = "read  counts")


#boxplot for normalised data 
par(cex.axis=0.5) 
par(mar=c(4,2,1,1))
study_colors = c(rep("#440154FF",3),rep("#31688EFF",22),rep("#FDE725FF",15),rep("#35B779FF",12))
norm_boxplot <- boxplot(counts_normalized, 
                        PchCex =0.01,
                        axes=TRUE,
                        las=2,
                        col=study_colors, 
                        ylim = c(0,4500),
                        outline =TRUE,
                        outcex=0.35,
                        main="deseq normalized, no transformation")
legend("topright", legend=c("E-MTAB-6011", "GEO:GSE67035", "GEO:GSE83814", "GEO:GSE100097"), 
               col = c("#440154FF","#31688EFF","#FDE725FF","#35B779FF"), 
               fill = c("#440154FF","#31688EFF","#FDE725FF","#35B779FF"),
               cex = 0.75, 
               pt.cex = 1)


```

3) Transformation: will use both Rlog and VST to see what gives best results. We know batch effects exist from plot of log counts

>For genes with high counts, both the VST and the rlog will give similar result 
to the ordinary log2 transformation of normalized counts. For genes with lower 
counts, however, the values are shrunken towards a middle value. The VST or 
rlog-transformed data then become approximately homoskedastic (more flat trend 
in the meanSdPlot), and can be used directly for computing distances between samples, making PCA plots, or as input to downstream methods which perform best with homoskedastic data. In datasets with large variation in sequencing depth (dynamic range of size factors 4) we observed undesirable artifacts in the performance of the VST

>The rlog is less sensitive to size factors, which can be an issue when size factors vary widely. Should check these for my samples. Try with both rlog and vst.

>The more the size factors differ, the more residual dependence of the variance on the mean will be found in the transformed data. rlog is a transformation which can perform better in these cases. As shown in the vignette, the function meanSdPlot from the package vsn can be used to see whether this is a problem.

```{r meanSDPlot}
library(vsn)
# When the expected amount of variance is approximately the same across different 
# mean values, the data is said to be homoskedastic. For RNA-seq counts, however, 
# the expected variance grows with the mean.
SdPlot <- meanSdPlot(counts_normalized, ranks = F, plot = F)  
SdPlot$gg + ggtitle("sequencing depth normalized") + ylab("standard deviation")




```



```{r rlog_transformation, message=FALSE}
# use raw count data, not normalised for sequencing depth

# rlog transformed blind=F
rld<-rlog(dds_raw, blind=F)
#create summarized experiment matrix (se=summarized experiment)
rlog_norm_se <- assay(rld)
                 
# rlog blind=T
rld_T<-rlog(dds_raw)
rlog_T_norm_se<-assay(rld_T)

par(mfrow=c(1,2))
plot(rlog_norm_se[,18:19], cex=.1, main = "rlog transformed, blind=F", xlim=c(0,18), ylim=c(0,18))

plot(rlog_T_norm_se[,18:19], cex=.1, main = "rlog transformed, blind=TRUE", xlim=c(0,18), ylim=c(0,18))
```
Don't see any difference with blind T/F. There are no controls set, so shouldn't really make a difference here. YenYi used blind=FALSE with VST. 

```{r boxplot_rlog}
par(mfrow=c(1,1))
rlog_boxplot <- boxplot(rlog_norm_se, 
                        PchCex =0.01,
                        axes=TRUE,
                        las=2,
                        col=study_colors, 
                        #ylim = c(0,4500),
                        outline =TRUE,
                        outcex=0.35,
                        main=c("rlog transformed"))
legend("topright", legend=c("E-MTAB-6011", "GEO:GSE67035", "GEO:GSE83814", "GEO:GSE100097"), 
               col = c("#440154FF","#31688EFF","#FDE725FF","#35B779FF"), 
               fill = c("#440154FF","#31688EFF","#FDE725FF","#35B779FF"),
               cex = 0.75, 
               pt.cex = 1)

```
There are still a lot of low counts here. 

VST transformation

```{r vst_transformation}

vst_dds<-vst(dds_raw, blind=F)
# create summarised experiment matrix from dds
vst_norm_se<-assay(vst_dds)

plot(vst_norm_se[,18:19], cex=.1, main = "vst transformed", xlim=c(0,18), ylim=c(0,18))

vst_boxplot <- boxplot(vst_norm_se, 
                        PchCex =0.01,
                        axes=TRUE,
                        las=2,
                        col=study_colors, 
                        #ylim = c(0,4500),
                        outline =TRUE,
                        outcex=0.35,
                        main="VST")
legend("topright", legend=c("E-MTAB-6011", "GEO:GSE67035", "GEO:GSE83814", "GEO:GSE100097"), 
               col = c("#440154FF","#31688EFF","#FDE725FF","#35B779FF"), 
               fill = c("#440154FF","#31688EFF","#FDE725FF","#35B779FF"),
               cex = 0.75, 
               pt.cex = 1)


```
A lot fewer low counts, but when I plot different studies against each other, lower correlation than with rlog. Perhaps this is because of different sequencing depths in the different studies. 

4) PCA plots and hierarchical dendrograms: these will help us identify any batch effects. 

>Related to the distance matrix is the PCA plot, which shows the samples in the 2D plane spanned by their first two principal components. This type of plot is useful for visualizing the overall effect of experimental covariates and batch effects.

There will be batch effects, we can try to eliminate using limma.

```{r PCA_rlog_transformation}
library(ggplot2)
library("pheatmap")
library(RColorBrewer)

# Sample distances with summarised exper of rlog counts (rld)
# rlog_norm_se <- assay(rld)
sampleDists_rld <- dist(t(rlog_norm_se))
head(sampleDists_rld)

# Transform sample distances to matrix
sampleDistMatrix_rld <- as.matrix( sampleDists_rld )

# Colors palette
hm_colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
study_colors <- c(rep("#440154FF",3),rep("#31688EFF",22),rep("#FDE725FF",15),rep("#35B779FF",12))

# Draw heatmap
heatmap <- pheatmap(sampleDistMatrix_rld,
                    clustering_distance_rows = sampleDists_rld,
                    clustering_distance_cols = sampleDists_rld,
                    col = hm_colors)

#not that useful because hard to see if batch effects going on--is there maybe a way to colour text of sample names by study? maybe add to annotation


#PCA plotting with DESeq2 in built function on conditions, plots using rlog transformed counts
PCA.prelim <- plotPCA(rld,intgroup="condition")
PCA.prelim

#generating PCA table 
PCA.data <- data.frame(row.names=colnames(countdata),
                               condition=factor(conditions$condition),
                               dataset=factor(conditions$study))
      
PCA.data.plot <- prcomp(t(rlog_norm_se))
pca_rlog_df <- as.data.frame(PCA.data.plot$x)
pca_rlog_df$condition<-PCA.data$condition
pca_rlog_df$dataset <-PCA.data$dataset
summary(PCA.data.plot)

#establishing a custom viridis colour palette
toned_down_pal <- c("#FFBF00","#31688EFF","#35B779FF","#CA0020")

#PCA plot for rlog transformed data 
custom <- ggplot(pca_rlog_df,aes(x=PC1,y=PC2,color=dataset,shape=condition)) + scale_shape_manual(values = 0:21) + geom_point(size=3) + xlab("PC1 (37%)") + ylab("PC2 (20%)")
custom <- custom + scale_color_manual(values = toned_down_pal) + theme_bw()
custom
```

```{r dendrogram_prelimma}
# make hierarchical dendrogram to compare with post-limma
#dendrogram for rlog transformed data

sizeGrWindow(12,9)
par(cex=0.6)
par(mar=c(5,6,2,0))

group <-as.factor(conditions$study) 
n_group <- length(unique(group)) 
cols <- toned_down_pal    #(n_group)
col_group <- cols[group] 
hc <- hclust(dist(t(rlog_norm_se)),method="average")
dend <- as.dendrogram(hc) 
col_group <- col_group[order.dendrogram(dend)] 
rlog_dend <- dend %>% 
            set("labels_colors", col_group) %>% #change label colors to group
            plot(main = "Dendrogram rlog transformed")
legend("topright", 
       legend = unique(group), 
       fill = cols, 
       cex = 0.75, 
       pt.cex = 1)

```
These show obvious batch effects, especially for studies GSE83814 and E-MTAB-6011.

5) Eliminate batch effects with limma

>The design matrix is used to describe comparisons between the samples, for example treatment effects, that should not be removed. The function (in effect) fits a linear model to the data, including both batches and regular treatments, then removes the component due to the batch effects.

>In most applications, only the first batch argument will be needed. This case covers the situation where the data has been collected in a series of separate batches.


```{r limma_batchcorr}
#batch effect correction using limma; requirement to define batch effect 
library(limma)

batch.table <- data.frame(study=conditions$study,condition=conditions$condition) 
#head(batch.table)

# uses log-expression values for series of samples, and needs design matrix
limma_rlog<-removeBatchEffect(x=rlog_norm_se,
                                      batch=batch.table$study,
                                      batch2=NULL,
                                      covariates=NULL,
                                      design=model.matrix(~batch.table$condition)) 
#Coefficients not estimable: batch1 batch2 batch3 
#Partial NA coefficients for 6486 probe(s)

#Despite warning, is limma still correcting for purposes of visualisation for use with pca, etc?

# make PCA plot for limma batch corrected

#generating PCA table 
PCA.data <- data.frame(row.names=colnames(countdata),
                               condition=factor(conditions$condition),
                               dataset=factor(conditions$study))
      
PCA.data.plot <- prcomp(t(limma_rlog))
pca_rlog_limma_df <- as.data.frame(PCA.data.plot$x)
pca_rlog_limma_df$condition<-PCA.data$condition
pca_rlog_limma_df$dataset <-PCA.data$dataset
summary(PCA.data.plot)

#PCA plot for rlog transformed data 
limma_plot <- ggplot(pca_rlog_limma_df,aes(x=PC1,y=PC2,color=dataset,shape=condition)) + scale_shape_manual(values = 0:21) + geom_point(size=3) + xlab("PC1 (32%)") + ylab("PC2 (18%)")
limma_plot <- limma_plot + scale_color_manual(values = toned_down_pal) + theme_bw()
limma_plot
## does not look corrected at all--identical plot to pre-limma?
# check dendrogram
```


```{r dedrogram_limma}
# make hierarchical dendrogram to compare with pre-limma
#dendrogram for rlog transformed data with batch correction
sizeGrWindow(12,9)
par(cex=0.6)
par(mar=c(5,6,2,0))

group <-as.factor(conditions$study) 
n_group <- length(unique(group)) 
cols <- toned_down_pal    #(n_group)
col_group <- cols[group] 
hc <- hclust(dist(t(limma_rlog)),method="average")
dend <- as.dendrogram(hc) 
col_group <- col_group[order.dendrogram(dend)] 
limma_rlog_dend <- dend %>% 
            set("labels_colors", col_group) %>% #change label colors to group
            plot(main = "Dendrogram rlog transformed and batch corrected")
legend("topright", 
       legend = unique(group), 
       fill = cols, 
       cex = 0.75, 
       pt.cex = 1)

# Exactly the same--no batch correction at all. Need to include some control data in the design? Maybe all exponential cultures?

```
I got this same message when doing limma on VST data.
I suspect it has more to do with lack of controls in design matrix.

Can I use day 3 and 4 from study GEO# GSE83814? These look like exponential growth. Can I use day 2?

![growth GEO:GSE83814](Images/growth_GSE83814.png)

So for controls: reaeration days 3-4, tyloxapol_pH7.0, dextrose exponential

Create new dseq matrix with control design. Start with new dataframe of conditions.

```{r control_df}

# replace reaeration days 3-4, tyloxapol ph7.0 and dextrose exponential with 'control'
controls<-c("reaeration_day3", "reaeration_day4", "tyloxapol_pH7.0", "dextrose_exponential")
# create new df from first two cols of old one
control_conditions.df<-data.frame(conditions[,1:2])
control_conditions.df[which(conditions$condition %in%       controls),2]<-'control' 
class(control_conditions.df)
View(control_conditions.df)
#write_table of df
write.csv(control_conditions.df, "~/git/mtb_modules/control_conditions_df.txt", quote=F, row.names = F, )
```

Create new deseq dataset with design matrix using controls

# create DeSeq dataset
```{r}
#this step defined control samples as the base reference 
control_conditions.df$condition <- factor(control_conditions.df$condition)
control_conditions.df$condition <- relevel(control_conditions.df$condition, "control") 
#if the metadata is somehow already ordered, this line unorders it (is this necessary?)
control_conditions.df$condition <- factor(control_conditions.df$condition, ordered = FALSE)
#check order is same for count data and conditions data
all(control_conditions.df$sample_names == colnames(countdata))


#construct deseq dataset
dds_control<-DESeqDataSetFromMatrix(countData = countdata,
                              colData = control_conditions.df,
                              design = ~condition)
nrow(dds_control)
#6486
# pre-filter reads to exclude rows with very low expression--makes more efficient
keep <- rowSums(counts(dds_control)) >= 10
dds_filter <- dds_control[keep,]
nrow(dds_filter)
#6483
# this filters only 3 rows, so not really much point, but might as well
dds_control<-dds_filter
```

Do rlog transformation blind T/F to see if control effects

```{r rlog_transf_control, message=FALSE}
# use raw count data, not normalised for sequencing depth

# rlog transformed blind=F
#rlog_control<-rlog(dds_control, blind=F)
#create summarized experiment matrix (se=summarized experiment)
#rlog_control_se <- assay(rlog_control)
                 
# rlog blind=T
rlog_control<-rlog(dds_control)
rlog_control_se<-assay(rlog_control)

par(mfrow=c(1,2))
plot(rlog_control_se[,18:19], cex=.1, main = "rlog transformed, blind=T", xlim=c(0,18), ylim=c(0,18))

```

```{r boxplot_rlog_controls}
study_colors <- c(rep("#440154FF",3),rep("#31688EFF",22),rep("#FDE725FF",15),rep("#35B779FF",12))
par(mfrow=c(1,1))
rlc_boxplot <- boxplot(rlog_control_se, 
                        PchCex =0.01,
                        axes=TRUE,
                        las=2,
                        col=study_colors, 
                        ylim = c(0,30),
                        outline =TRUE,
                        outcex=0.35,
                        main=c("rlog transformed with controls"))
legend("topright", legend=c("E-MTAB-6011", "GEO:GSE67035", "GEO:GSE83814", "GEO:GSE100097"), 
               col = c("#440154FF","#31688EFF","#FDE725FF","#35B779FF"), 
               fill = c("#440154FF","#31688EFF","#FDE725FF","#35B779FF"),
               cex = 0.75, 
               pt.cex = 1)

```

use limma to attempt to eliminate batch effects:

```{r limma_batchcorr_controls}
#batch effect correction using limma; requirement to define batch effect 
library(limma)
batch.table2 <- data.frame(study=conditions$study,
                           condition=control_conditions.df$condition) 

# uses log-expression values for series of samples, and needs design matrix
limma_rlogc<-removeBatchEffect(x=rlog_control_se,
                                  batch=batch.table2$study,
                                  batch2=NULL,
                                  covariates=NULL,
                              design=model.matrix(~batch.table2$condition)) 

#Coefficients not estimable:  batch3 
#Partial NA coefficients for 6486 probe(s)
head(limma_rlogc)

# write to csv to save for wgcna: 
write.csv(limma_rlogc2, "~/git/mtb_modules/limma_rlogc.csv", quote=F)

```
Look at PCA for limma corrected.

```{r pca_limma_rlogc}
# make PCA plot for limma batch corrected control set (limma_rlogc)
#establishing a custom viridis colour palette
toned_down_pal <- c("#FFBF00","#31688EFF","#35B779FF","#CA0020")

#generating PCA table 
PCA.data <- data.frame(row.names=colnames(countdata),
                               condition=factor(conditions$condition),
                               dataset=factor(conditions$study))
      
PCA.data.plot <- prcomp(t(limma_rlogc))
pca_rlogc_limma_df <- as.data.frame(PCA.data.plot$x)
pca_rlogc_limma_df$condition<-PCA.data$condition
pca_rlogc_limma_df$dataset <-PCA.data$dataset
summary(PCA.data.plot)

png("PCA12_rlog_limma.png", type="quartz", width=720, height=480)
#PCA plot for rlog transformed data 
limma_rlogc_plot <- ggplot(pca_rlogc_limma_df,aes(x=PC1,y=PC2,color=dataset,shape=condition)) + scale_shape_manual(values = 0:21) + geom_point(size=3) + xlab("PC1 (33%)") + ylab("PC2 (24%)")
limma_rlogc_plot <- limma_rlogc_plot + scale_color_manual(values = toned_down_pal) + theme_bw()
limma_rlogc_plot
dev.off()

#PC 2 and 3
limma_rlogc_plot23 <- ggplot(pca_rlogc_limma_df,aes(x=PC2,y=PC3,color=dataset,shape=condition)) + scale_shape_manual(values = 0:21) + geom_point(size=3) + xlab("PC2 (24%)") + ylab("PC3 (11%)")
limma_rlogc_plot23 <- limma_rlogc_plot23 + scale_color_manual(values = toned_down_pal) + theme_bw()
limma_rlogc_plot23

#PC 3 and 4
limma_rlogc_plot34 <- ggplot(pca_rlogc_limma_df,aes(x=PC3,y=PC4,color=dataset,shape=condition)) + scale_shape_manual(values = 0:21) + geom_point(size=3) + xlab("PC3 (11%)") + ylab("PC4 (7%)")
limma_rlogc_plot34 <- limma_rlogc_plot34 + scale_color_manual(values = toned_down_pal) + theme_bw()
limma_rlogc_plot34


```

Dendrogram to look at hierarchical clustering

```{r dendrogram_limma_controls}
# make hierarchical dendrogram to compare with pre-limma
#dendrogram for rlog transformed data with batch correction
sizeGrWindow(12,9)
par(cex=0.6)
par(mar=c(5,6,2,0))

group <-as.factor(conditions$study) 
n_group <- length(unique(group)) 
cols <- toned_down_pal    #(n_group)
col_group <- cols[group] 
hc_logc <- hclust(dist(t(limma_rlogc)),method="average")
dend_logc <- as.dendrogram(hc_logc) 
col_group <- col_group[order.dendrogram(dend_logc)] 
limma_rlogc_dend <- dend_logc %>% 
            set("labels_colors", col_group) %>% #change label colors to group
            plot(main = "Dendrogram rlog transformed and batch corrected")
legend("topright", 
       legend = unique(group), 
       fill = cols, 
       cex = 0.75, 
       pt.cex = 1)
png("~/git/mtb_modules/limma_rlogc_dend.png", width=1000, height = 800)
limma_rlogc_dend <- dend_logc %>% 
            set("labels_colors", col_group) %>% #change label colors to group
            plot(main = "Dendrogram rlog transformed and batch corrected")
legend("topright", 
       legend = unique(group), 
       fill = cols, 
       cex = 0.75, 
       pt.cex = 1)
dev.off()
```
Yay, that seemed to work, controls seem to cluster together, along with re-aeration days 1 and 2, and high iron.

![batch correction dendrogram with controls](Images/limma_rlogc_dend_controls.png)

6) WGCNA 

[WGCNA website](https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/)

[blockwise analysis for large datasets](https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-02-networkConstr-blockwise.pdf)

Do we need to do blockwise analysis? We have 6000+ genes.
"A 16GB workstation should handle up to 20000 probes. In general it is preferable to analyze a data set in as few blocks as possible" I've set max block size as 6500 so that should include all the genes. THese should have very similar results, and since I did it all in one block anyway, shouldn't be an issue.

```{r data_formatting}
#WGCNA 

library(WGCNA)
options(stringsAsFactors = FALSE)

# rather than generate limma_rlogc every time, can use limma_rlogc.csv
# these are batch corrected expression values:
limma_rlogc<-read.csv("~/git/mtb_modules/limma_rlogc.csv", header = T, row.names = 1)  #row.names=1 so won't assign colname to col of rownames

analysis <- as.data.frame(t(limma_rlogc))

head(analysis)
# rows are samples (52), cols are genes (6483)
dim(analysis)

save(analysis, file = "~/git/mtb_modules/datExpr.RData")

#defining trait data with control conditions 
#control_conditions.df<-
#               read.csv("~/git/mtb_modules/control_conditions_df.txt",                 )

traitData <- control_conditions.df
dim(traitData)

# column names are 'sample_names' and 'condition'
#reformatting data to match
sample.names <- rownames(analysis)
traitRows    <- match(colnames(rlog_control_se),traitData$sample_name)
datTraits    <- traitData[traitRows,-1, drop=FALSE]  ## drop = F so that stays a dataframe instead of factor
#relabel row names with sample names 
rownames(datTraits)         <- traitData[traitRows,1]
datTraits[is.na(datTraits)] <- 0 
head(datTraits)
# save for further analysis
save(datTraits, file="~/git/mtb_modules/datTraits.RData")
#head(datTraits)
```

```{r soft_threshold_choice}
 #choose a set of soft-thresholding powers
        powers = c(c(1:10), seq(from = 12, to=20, by=2))
        #call the network topology analysis function
        sft = pickSoftThreshold(analysis, 
                                powerVector = powers, 
                                verbose = 5)
        #plotting the output 
        sizeGrWindow(9, 5)
        par(mfrow = c(1,1))
        cex1 = 0.9
        # Scale-free topology fit index as a function of the soft-thresholding power
        plot(sft$fitIndices[,1], 
             -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
             xlab="Soft Threshold (power)",
             ylab="Scale Free Topology Model Fit,signed R^2",
             type="n",
             main = paste("Scale independence"))
        text(sft$fitIndices[,1], 
             -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
             labels=powers,
             cex=cex1,
             col="red")
        #R^2 cut-off line
        abline(h=0.80,col="red")
        #mean connectivity as a function of the soft-thresholding power
        plot(sft$fitIndices[,1], 
             sft$fitIndices[,5],
             xlab="Soft Threshold (power)",
             ylab="Mean Connectivity", 
             type="n",
             main = paste("Mean connectivity"))
        text(sft$fitIndices[,1], 
             sft$fitIndices[,5], 
             labels=powers, 
             cex=cex1,
             col="red")
```

I will try 14 first and see how that looks.

Parameters that may need adjustment:

corType="bicor": biweight midcorrelation (vs Pearson)
I think this is faster and requires less computation than pearson?
(Looking up info on this in this book: "Introduction to Robust Estimation and Hypothesis Testing", Rand Wilcox, Academic Press, 1997.)

'deepSplit' is measure of how sensitive module detection should be to module splitting. 0-4, 4 is most sensitive, 2 is medium 

'minModuleSize' is minimum module size for module detection

'reassignThreshold' is p-value ratio threshold for reassigning genes between modules
>After all blocks have been processed, the function checks whether there are genes whose KME in the module they assigned is lower than KME to another module. If p-values of the higher correlations are smaller than those of the native module by the factor reassignThresholdPS, the gene is re-assigned to the closer module.

'mergeCloseModules'
>In the last step, modules whose eigengenes are highly correlated are merged. This is achieved by clustering module eigengenes using the dissimilarity given by one minus their correlation, cutting the dendrogram at the height mergeCutHeight and merging all modules on each branch. The process is iterated until no modules are merged. See mergeCloseModules for more details on module merging.

'mergeCutHeight': dendrogram cut height for module merging.


```{r coexpression_network}
#create coexpression network and identify modules
net = blockwiseModules(analysis, 
                      maxBlockSize = 6500,     
                      corType = "bicor", 
                      networkType = "signed",
                      power = 14, 
                      TOMType = "signed", 
                      minModuleSize = 20,
                      reassignThreshold = 0, 
                      mergeCutHeight = 0.15, 
                      deepSplit = 2,
                      numericLabels = TRUE,
                      saveTOMs = TRUE,
                      saveTOMFileBase = "testTOM", 
                      pamRespectsDendro = FALSE,
                      verbose = 3)
summary(net)

#how many modules identified and what colours are
module.table <- table(net$colors)  #this creates a 'contingency table'

write.csv(table(net$colors), file = "clusteringblocks.csv")

# display dendrogram 
png("power14_split2_minmod20_cuth15.png", width=1000, height=650)
#sizeGrWindow(12, 9)
#convert labels to colours for plotting
mergedColors <- labels2colors(net$colors)

#plot dendrogram and module colors underneath
plotDendroAndColors(net$dendrograms[[1]], 
                    mergedColors[net$blockGenes[[1]]],
                    "Module colors",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
dev.off()
#save the module assignment and module eigengene info for subsequent analysis
# each gene assigned a module number
moduleLabels = net$colors
#each gene assigned a color
moduleColors = labels2colors(net$colors)

# module eigengenes
MEs = net$MEs;
#MEs

#save dendrogram data (hclust)
geneTree = net$dendrograms[[1]];

# this saves info as R object
#save(MEs, moduleLabels, moduleColors, geneTree, 
#     file = "~/git/mtb_modules/TB_modules_network_construction.RData")

# to re-load modules data (MEs, etc)
load("~/git/mtb_modules/TB_modules_network_construction.RData")


table(moduleColors)
s<-as.data.frame(table(moduleColors), row.names = NULL,
              responseName = "Freq", stringsAsFactors = TRUE,
              sep = "", base = list(LETTERS))
s<-s[order(s$Freq, decreasing = T),]
head(s)
# turquoise, blue, brown, yellow, green, red are largest modules

write.csv(table(moduleColors), file = "clusteringblocks2.csv")

```

With 14: 
Not horrible, but maybe not as defined gene modules as I would like? good separation of colours, however?
Creates 38 clusters. 132 genes unassigned.
Try with 16: Looks worse.

Try deepSplit=3, no difference.
30 is a 'relatively large' minimum module setting acc to tutorial
minmodulesize up to 25 (from 20). This may put more in unassigned?
37 modules, 135 unassigned. not much different. 
try 30: 29 modules, 290 unassigned, no real improvement in dendrogram.

change mergecutheight to .15 from .25 (kept minmodule size at 30)
THis causes a lot more modules: 47.

minmodulesize=20, mergecutheight=.15. now it's 63 modules!Dendrogram looks similar, just more colours on bottom. With lower merge cut height, fewer modules are merged on each branch.

Going with this one for now--more modules. Let's see if we get some results with this--can always go back and raise the merge cut height and minmodulesize again.

[module determination wgcna tutorial](https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/Simulated-05-NetworkConstruction.pdf)

TOM plot is a network connectivity plot that shows relationship between genes in module--shows intramodule connectivity in a heatmap

To get a sense how related modules are to one another--can summarize each module by its eigengene (1st PC):

The eigengene dendrogram and heatmap identify groups of correlated eigengenes termed 'meta-modules'. 


```{r adjacency_heatmap}
#define numbers of genes and samples
nGenes = ncol(analysis)
nSamples = nrow(analysis)
#recalculate MEs with color labels
MEs0 = moduleEigengenes(analysis, moduleColors)$eigengenes
#MEs0
MEs = orderMEs(MEs0)
#head(MEs)

# Plot the heatmap matrix 
par(cex = 1.0)
plotEigengeneNetworks(MEs, "Eigengene adjacency heatmap", 
                      marHeatmap = c(3,4,2,2),
                      plotDendrograms = FALSE, 
                      xLabelsAngle = 90)

```



```{r}
# look at pairwise observations (use="p", method="pearson", default)
sum_conn<-signif(cor(MEs, use="p"), 2)
#sum_conn[1:10,]
# use this to cluster the eigengenes
dissimME=(1-t(cor(MEs, method="p")))/2 
hclustdatME=hclust(as.dist(dissimME), method="average" )
# Plot the eigengene dendrogram
png("~/git/mtb_modules/clust_eigengenes.png", height = 800, width=1200)
par(mfrow=c(1,1))
plot(hclustdatME, main="Clustering tree based on the module eigengenes")
dev.off()
```

![clustering tree of MEs](~/git/mtb_modules/clust_eigengenes.png)

Make heatmap plots of module expressions. This may help identify modules that are “held together” by spurious correlations caused by outlying arrays

```{r heatmap_plots_modules}
#make heatmaps of module membership for 5 biggest modules

png("mod_mem_heatmaps.png", width=1000, height=3000)
#sizeGrWindow(8,9)
par(mfrow=c(5,1), mar=c(1, 2, 4, 1))
for (i in 1:5){
  which.module=s$moduleColors[i];
  plotMat(t(scale(analysis[,moduleColors==which.module ])),
        nrgcols=63,
        rlabels=T,
        clabels=T,
        rcols=which.module, 
        title=which.module )
}  
dev.off()
```

![heatmaps of 5 largest modules](~/git/mtb_modules/mod_mem_heatmaps.png)

[wgcna tutorial on visualising networks](https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/FemaleLiver-05-Visualization.pdf)


>It is often interesting to study the relationships among the found modules. One can use the eigengenes as representative profiles and quantify module similarity by eigengene correlation. The package contains a convenient function plotEigengeneNetworks that generates a summary plot of the eigengene network. It is usually informative to add a clinical trait (or multiple traits) to the eigengenes to see how the traits fit into the eigengene network:

How to use plotEigengeneNetwork without adding traits? (datTraits)

I want to measure module significance to determine which are most interesting modules:

>Measure of module significance as average gene significance
>One can also define a measure of module significance as the average gene significance of all genes in the module. We use the absolute value for defining a correlation based gene significance measure.
>A gene significance measure could be defined without reference to a sample trait. For example, it could indicate pathway membership (1 or 0) or essentiality (1 or 0). 

We could find some gene pathways associated with certain genes in particular modules and test module for correlation with that pathway?

First do some trait correlation: hypoxia (+dextrose dormancy), low iron, cholesterol, control=exponential?

2 methods.

1) Correlate the module eigengenes with the trait
2) use avg gene significance to measure module significance


```{r trait_data}

#We use the absolute value for defining a correlation based gene significance measure.
# need to define gene significance
# y is a particular trait we want to look at
# y=datTraits$y

# rearrange so condition is column and associated samples = 1, unassociated samples = 0

trait_df<-data.frame(matrix(0, nrow = nrow(control_conditions.df), ncol=14))
dim(trait_df)
# hypoxia includes dextrose_NRP1dormancy, cholesterolfattyacids_NRP1dormancy, and hypoxia_day0
# exponential is all control conditions (dextrose exponential, later reaeration)
# cholesterol includes all growth phases? (exponential, stationary, dormancy)
rownames(trait_df)<-control_conditions.df$sample_names
colnames(trait_df)<-c("ammonium", "histidine", "lysine", "dormancy", "reaeration_1to2", "exponential", "butyrate", "butyrate_plus_glu", "glucose", "hi_iron", "low_iron", "acid", "cholesterol", "stationary")
trait_df$ammonium[1]<-1
trait_df$histidine[2]<-1
trait_df$lysine[3]<-1
trait_df$dormancy[c(4,5,6, 45,46, 51, 52)]<-1  #hypoxia and dormancy
trait_df$reaeration_1to2[c(7:12)]<-1
trait_df$exponential[c(13:18, 37,38, 41,42)]<-1 
trait_df$butyrate[c(19:24)]<-1
trait_df$butyrate_plus_glu[c(22:24)]<-1
trait_df$glucose[c(22:24, 25:27)]<-1
trait_df$hi_iron[c(28:30)]<-1
#trait_df$low_iron_1day[c(31:33)]<-1
#trait_df$low_iron_1week[c(34:36)]<-1
trait_df$low_iron[c(31:36)]<-1
trait_df$acid[c(39,40)]<-1
trait_df$cholesterol[c(47:52)]<-1 #also 51 and 52 in dormancy
#trait_df$dext_stat[c(43,44)]<-1
#trait_df$dext_dorm[c(45,46)]<-1 (add this to hypoxia)
#trait_df$chol_expo[c(47,48)]<-1
#trait_df$chol_stat[c(49,50)]<-1
#trait_df$chol_dorm[c(51,52)]<-1
trait_df$stationary[c(43,44,49,50)]<-1   # stat cholesterol,dextrose
View(trait_df)
```

```{r module_significance}
#1 correlate module eigengenes with trait
y = trait_df$hypoxia
hypox_signif<-signif(cor(y,MEs, use="p"),2)
# using pearson? wouldn't kendall be better or is there something else? 

int_hypox<- data.frame(hypox_signif[1,abs(hypox_signif)>0.4])
nrow(int_hypox) #24 (down to 11 without dextrose_dorm)
colnames(int_hypox)<-c("correlation")

max(hypox_signif) #turquoise (0.53) #these values went down when i removed samples associated with hypoxia such as dext dorm.j Only dark green still > 0.5 (-0.51)
min(hypox_signif) #maroon (-0.60)

# compute p-values with interesting modules
turq_test<-cor.test(y, MEs$MEturquoise)
turq_test
turq_test$p.value
#4.978723e-05  # significance of these particular modules much less without dextrose_dormancy
maroon_test<-cor.test(y, MEs$MEmaroon)
maroon_test$p.value
#2.400853e-06
MEs_hypox<-rownames(int_hypox)

#get all p-values
p.values = corPvalueStudent(cor(y,MEs[MEs_hypox], use="p"), nSamples = length(y))
#add to df
int_hypox$p_value<-t(p.values)

# use control/exponential
y = trait_df$exponential
expo_signif<-signif(cor(y,MEs, use="p"),2)
int_expo<- data.frame(expo_signif[1,abs(expo_signif)>0.5])
nrow(int_expo) #4
colnames(int_expo)<-c("correlation")
int_expo
#            correlation
#MEbrown4           0.57
#MEwhite           -0.58
#MEthistle1        -0.55
#MEroyalblue        0.53

MEs_expo<-rownames(int_expo)
#get all p-values
p.values = corPvalueStudent(cor(y,MEs[MEs_expo], use="p"), 
                            nSamples = length(y))
#add to df
int_expo$p_value<-t(p.values)

# low-iron
y = trait_df$low_iron
iron_signif<-signif(cor(y,MEs, use="p"),2)
int_iron<- data.frame(iron_signif[1,abs(iron_signif)>0.5])
nrow(int_iron) #7
colnames(int_iron)<-c("correlation")
int_iron
#                 correlation
#MEsteelblue             0.57
#MEdarkorange            0.59
#MEcoral1               -0.51
#MEpalevioletred3       -0.56
#MEantiquewhite4         0.52
#MElightpink4            0.52
#MEmaroon                0.64

MEs_iron<-rownames(int_iron)
#get all p-values
p.values = corPvalueStudent(cor(y,MEs[MEs_iron], use="p"), 
                            nSamples = length(y))
#add to df
int_iron$p_value<-t(p.values)

#acid
y = trait_df$acid
acid_signif<-signif(cor(y,MEs, use="p"),2)
int_acid<- data.frame(acid_signif[1,abs(acid_signif)>0.4])
nrow(int_acid) #0
# none correlated with acid (only 2 samples)

# cholesterol
y = trait_df$cholesterol
chol_signif<-signif(cor(y, MEs, use="p"),2)
int_chol<-data.frame(chol_signif[1,abs(chol_signif)>0.4])
nrow(int_chol) #7 (using lower threshold of 0.4)
#add to df
colnames(int_chol)<-c("correlation")
MEs_chol<-rownames(int_chol)
#get all p-values
p.values = corPvalueStudent(cor(y,MEs[MEs_chol], use="p"), 
                            nSamples = length(y))
#add to df
int_chol$p_value<-t(p.values)
int_chol
#           correlation      p_value
#MEgreen           0.50 1.545646e-04
#MEmagenta         0.43 1.654566e-03
#MEdarkgrey        0.45 7.378448e-04
#MEdarkred         0.56 1.348458e-05
#MEyellow         -0.43 1.555336e-03
#MEplum1          -0.44 1.191917e-03
#MEsienna3        -0.47 4.000961e-04

# 2 measure of module significance as avg gene significance
# what is datExp?
y = trait_df$hypoxia
GS1=as.numeric(cor(y,analysis, use="p"))
GeneSignificance=abs(GS1)

# Next module significance is defined as average gene significance.
ModuleSignificance=tapply(GeneSignificance, moduleColors, mean, na.rm=T)

#Plot gene significance against module membership:
sizeGrWindow(8,7)
par(mfrow = c(1,1))
plotModuleSignificance(GeneSignificance,moduleColors, "Gene significance across modules, hypoxia")

```

Maybe should use different function for this: bicorAndPvalue instead of this cor test that finds Pearson correlations.This is what Yen-Yi did.

>faster, one-step calculation of Student correlation p-values for multiple biweight midcorrelations, properly taking into account the actual number of observations. 

```{r bicor_method}
#construction of biweight midcorrelation and fdr corrected significance of module eigengenes and experimental conditions
# robustY = F because using binary data for this trait
moduleTraitBicor.data = bicorAndPvalue(MEs, 
                              trait_df, 
                              maxPOutliers=0.05, 
                              robustY = FALSE)
moduleTraitBicor <- moduleTraitBicor.data$bicor
moduleTraitBicorPvalue = as.data.frame(moduleTraitBicor.data$p)

# fdr for multiple testing applied for each trait
traitNames<-colnames(trait_df)
modNames <- substring(colnames(MEs),3)
p_adj_bicor<-data.frame(matrix(0, nrow=length(modNames),
              ncol=length(traitNames)), 
              row.names = modNames)
colnames(p_adj_bicor)<-traitNames
traitNames == colnames(moduleTraitBicorPvalue)
for (i in 1:length(traitNames)){
    p_adj_bicor[,i]<-p.adjust(moduleTraitBicorPvalue[,i],method="fdr")
        }
#View(p_adj_bicor)
# convert df to matrix
p_adj_moduleTraitBicorPvalue <- as.matrix(p_adj_bicor)

# make heatmap of module/trait correlations
# this includes bicor correlation calc / adjusted p-value
textMatrix <- paste(signif(moduleTraitBicor, 2), 
                             "\n(",
                             signif(p_adj_moduleTraitBicorPvalue, 1), 
                             ")", 
                             sep = "")
View(textMatrix)
dim(textMatrix) <- dim(moduleTraitBicor)
#sizeGrWindow(10,6)
#par(mar = c(8, 12, 2, 2))
png("labeled_heatmap.png", width = 1920, height = 1920)
#heatmap plot 
        labeledHeatmap(Matrix <- moduleTraitBicor,
                       xLabels = colnames(trait_df),
                       yLabels = colnames(MEs),
                       ySymbols = colnames(MEs),
                       colorLabels = TRUE,
                       colors = blueWhiteRed(50),
                       textMatrix = textMatrix,
                       setStdMargins = FALSE,
                       cex.text = 1,
                       cex.lab.x = 1,
                       cex.lab.y = 1,
                       zlim = c(-1,1),
                       main = paste("Module-trait relationships FDR adjusted p-values"))
dev.off()
```
![heatmap trait/module correlations and p-values](~/git/mtb_modules/labeled_heatmap.png)

Combining cholesterol samples gives some more modules with significant correlation. Also, combining low iron and dormancy. 3 minimal media with specific amino acids all correlating together. butyrate/glucose no real change with combining-still not informative.

There are some interesting modules that are upregulated in dormancy and downregulated in exponential.

Now how do we look at what genes are members of particular modules? How to determine if they are functionally related?
I am more interested in describing the relationships between genes in one module.

[determining membership in important modules](https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/Simulated-07-Membership.pdf)

```{r}
#calculate intramodular connectivity ('degree')
#whole network connectivity = kTotal
#within module connectivity = kwithin
#kOut=kTotal-kWithin
#kDiff=kIn-kOut=2*kIn-kTotal

ADJ1=abs(cor(analysis, use="p"))^14     #they use 6 in tutorial which is same as soft power threshold they use. should i use softpower threshold I used? (14)
Alldegrees1=intramodularConnectivity(ADJ1, moduleColors)
head(Alldegrees1)

#plot the gene significance against intramodular connectivity
# but I don't know how to decide gene significance? by condition?

colorlevels=unique(moduleColors)
sizeGrWindow(9,6) 
par(mfrow=c(2,as.integer(0.5+length(colorlevels)/2))) 
par(mar = c(4,5,3,1))
for (i in c(1:length(colorlevels)))
{
  whichmodule=colorlevels[[i]];
  restrict1 = (moduleColors==whichmodule);
  verboseScatterplot(Alldegrees1$kWithin[restrict1],
                   GeneSignificance[restrict1],
                   col=moduleColors[restrict1],
                   main=whichmodule,
                   xlab = "Connectivity", ylab = "Gene Significance", abline = TRUE)
}

```

define a module eigengene-based connectivity measure for each gene as the correlation between a the gene expression and the module eigengene

>kMEbrown(i) = cor(xi, MEbrown)

xi is the gene expression profile of gene i and MEbrown is the module eigengene

```{r gene_expr_me_cor}
# create dataframe with module membership values (MM) for each module
# values are module membership for each gene in each module

datKME=signedKME(analysis, MEs, outputColumnName = "MM.")
head(datKME)

```



